/*
* Created by Vivek Sharma on 7/10/20.
 * This file contains function to compute pi protocol using unpacked method.
*/

//include the system defined header files
#include <iostream>
#include <random>
#include <bitset>
#include <cmath>
#include <chrono>
#include <ctime>
#include <cstdlib>

//include the user defined header files

#include "dmweakPRF.h"
#include "pi23prot.h"
#include "dmweakPRFnoPack.h"

using namespace std;
//variable declaration for 4 words
uint64_t X[4], Rx[4], B[4], Rb[4];//packed version of values
uint64_t A[4][256], Ra[4][256];
uint64_t Z[4], poly_eval_2PC[4], RaRx[4];
uint64_t Ma[4][256];


uint64_t Mx[4];
//variable declaration for unpacked 256 bits
uint64_t X_unpck[256];
uint64_t Z_unpck[4];
uint64_t Ra_unpck[256], Rb_unpck[256], Rx_unpck[256];
uint64_t RaRx_unpack[256];
uint64_t Mx_unpck[256];
uint64_t B_unpck[256];
uint64_t Mb_first[256];
uint64_t Mb_unpck[256];
uint64_t Ma_X[256];



//uint64_t MxGlobal[4];//global variable for Mx
uint64_t global_res[4];//value that stores the result computed using

int main()
{
    unsigned seed = 7;    // std::chrono::system_clock::now().time_since_epoch().count();
    std::mt19937 generator(seed);

    //generating Ra, Rb and Rx and computing Z = RaRx + Rb
    generate_rand_input(Rx,generator); //generated Rx is a 4 word value.
    generate_rand_key(Ra,generator);
    generate_rand_input(Rb,generator);

    //unpacking Ra, Rb and Rx into Ra_unpck, Rb_unpck and Rx_unpck
    unpack(Rx,Rx_unpck);
    unpack(Rb,Rb_unpck);
    mat_vec_mult(Rx, Ra, RaRx_unpack);//RaRx_unpack[256] = Ra(packed)[4][256] * Rx[256]

    //computing Z as part of preprocessing using unpacked method
    for(int i = 0; i < 256; i++)
    {
        Z_unpck[i] = RaRx_unpack[i] + Rb_unpck[i];
    }

    //Party 2 generates random values for X and Rx.
    generate_rand_input(X,generator); //generated X is a 4 word (uint64_t) value.
    unpack(X,X_unpck);
    cout<<endl<<"=====================================Party 2========================================"<<endl;
    cout<<"Input values generated by Party 2"<<endl;

    //Using X and Rx, compute Mx. Mx is also a 4 word value which is computed using multProtP2Part1
    for (int iRow = 0; iRow < 4; iRow++)
    {
        Mx[iRow] = X[iRow] - Rx[iRow]; //Mx = X - R; generated by party 2
    }
    unpack(Mx,Mx_unpck);


    //Party 1 generates A, B; while Ra and Rb are already generated in preprocessing
    generate_rand_key(A,generator);
    generate_rand_input(B,generator);
    unpack(B,B_unpck);

    cout<<endl<<"=====================================Party 1========================================"<<endl;
    cout<<"Random Input generated by Party 1";

    /*
     * 1. Using A and Ra, compute Ma....Ma = A - Ra
     * using values A, B, Ra, Rb compute out. which is a matrix vector multiplication
     * of Ra and Mx.
    */
    //multProtP1(A,B,Ra,Rb);
    for (int iRow = 0; iRow < 4; iRow++)
    {
        for (int jCol = 0; jCol < 256; jCol++)
        {
            Ma[iRow][jCol] = A[iRow][jCol] - Ra[iRow][jCol]; //Ma = A - Ra
        }
    }
    mat_vec_mult(Mx,Ra, Mb_first);
    for (int iCol = 0; iCol < 256; iCol++)
    {
        Mb_unpck[iCol]= Mb_first[iCol] + B[iCol] - Rb[iCol]; //Mb = Mb_first + B - Rb
    }
    cout<<endl<<"=====================================Party 2========================================"<<endl;

    //multiply Ma and X
    mat_vec_mult(X,Ma,Ma_X);
    for (int i = 0; i < 256; i++)
    {
        poly_eval_2PC[i] = Ma_X[i] + Mb_unpck[i] + Z_unpck[i];
    }
    //generate_rand_input(Z,generator);
    //multProtP2Part2(X,Z,poly_eval_2PC);     //evaluation of polynomial using Ma*X + Mb + Z

    poly_eval_global(A,X,B, global_res);    //evaluation of polynomial using Ax+B

    poly_eval_test(poly_eval_2PC, global_res); //comparing both the outputs to compare the result
    //Printing out the result for direct comparison.
    cout<<endl<<"poly_2PC"<<"\t"<<"global_res"<<endl;
    for(int i = 0; i < 4; i++)
    {
        cout<<poly_eval_2PC[i]<<"\t"<<global_res[i]<<endl;
    }




    return 0;
}


