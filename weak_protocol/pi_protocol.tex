\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amscd, amsthm, amsfonts}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{authblk}
\usepackage{datetime}

\oddsidemargin 0pt
\evensidemargin 0pt
\marginparwidth 40pt
\marginparsep 10pt
\topmargin -20pt
\headsep 10pt
\textheight 8.7in
\textwidth 6.65in
\linespread{1.2}

\title{Weak PRF Protocol: Pseudocode}
\author{Vivek Sharma}
\date{Jan 11, 2020}

\newcommand{\rr}{\mathbb{R}}

\newcommand{\al}{\alpha}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\aff}{aff}

\begin{document}

\maketitle


\section{Fully Distributive Evaluation Protocol}
The key is structured as a vector in $\mathbb{Z}_2$


The protocol is divided into three phases:

\subsection{Phase 1: NonInteractive computation of Additive share by each Server} 
Each server $S_{i}$ holds replicated additive shares of key $k_{i} \in \mathbb{Z}_{n}^{2}$ and $x_{i} \in \mathbb{Z}_{n}^{2}$ and computes $h_{i} \in \mathbb{Z}_{2}^{m}$, which is the multiplication of key and input over $\mathbb{Z}_2$. This computation is performed locally. 
\subsection{Phase 2: Interactive computation of $\pi_{23}$ protocol}

\begin{enumerate}
	\item Each server, at this point have locally computed their shares, which was the multiplication of two vectors.
	\item Server 1 randomly chooses a value $c \in \mathbb{Z}_{3}^{m}$ and each bit of value is converted to it's 2-bit representation to form $c_{0}$ and $c_{1}$ respectively. 
	\item Meanwhile, Server 1, 2 and 3 runs sub-protocol for m instances(m is the length of additive share and also the value of c, which is with server 1.
	\subitem For $1 \leq j \leq m$:
	\subitem Each server $s_{i} , i \in {1,2,3}$ share their input $h_{i,j}$ [\,Note: $h_{i,j}$ is the input of server $s_{i}$ in $j^{th}$ iteration ]\,
	\subitem Compute combined XOR of their input: $comb := h_{1} \oplus h_{2} \oplus h_{3}$
	\subitem Multiply one part of c$(c_{0}),$ with comb and other part $(c_{1})$ with $\neg{comb}$ and XOR both the result, this forms $d_{0}$.
	\subitem To compute $d_{1}$, XOR the $c_{0}$ and $\neg{c_{1}}$, and multiply the result with the XOR of secret share of the servers.
	\subitem The final result $d = d_{0}, d_{1} \in \{ 0,1\}^{2}$ is converted back into $\mathbb{Z}_{3}$
	\subitem At the end of this phase, Server 1 has $c \in \{0,1\}^m$ and Server 2 has received the output $d \in \mathbb{Z}_{3}$. The combination of values with Server one and two (i.e. c and d ) yields the additive mod 3 of the secret share of the inputs by the Servers. Mathematically $c + d = h_{1} + h_{2} + h_{3} (mod 3)$
\end{enumerate}

\subsection{Phase 3: Non Interactive evaluation of function map by Server 1 and Server 2}
The Servers in possession of random value c and the interactively computed value d, apply $map_{G}$ function on their input and compute their share in $\mathbb{Z}_3$. Note: This $map_{G}$ is guessed to be the additive mod G function, we saw at the implementation of weak PRF.

\section{Pseudocode}

\subsection{piprotocol():}
\begin{enumerate}
	\item Server $S_{i}$ : $h_{i}  := k \cdot x  $ (mod 2) $\in \mathbb{Z}_{2}^{m}$. //matrix vector multiplication
	\item $S_{1}$ : Selects c $\xleftarrow{\text{R}} \mathbb{Z}_{3}^{m}$. //randomly selected from the field.
	\item for $1 \leq j \leq m$: //length of c and $h_{i}$
	\item \quad Server $S_{i}$ : $\pi_{2,3}$($c_{0}, c_{1}, h_{1}, h_{2}, h_{3}$) //All servers run parallel instances of the protocol
	\item $S_{1}$: $\sum_{1 \leq n \leq m} c_{n} $ (mod G) and $S_{2}$: $\sum_{1 \leq n \leq m} d_{n} $ (mod G)
\end{enumerate}

\subsection{$\pi_{2,3}$($c_{0}, c_{1}, h_{1}, h_{2}, h_{3}$):}
\begin{enumerate}
	\item $comb := h_{1} \oplus h_{2} \oplus h_{3}$ //secret share of each server at $j^{th} iteration$
	\item $d_{0} = c_{0} \cdot comb \oplus c_{1} \cdot \neg comb$
	\item $d_{1} = c_{0} \oplus \neg c_{1} \cdot comb$
	\item return $d_{0} and d_{1}$ //Server two obtains d by combining $d_{0} and d_{1}$
\end{enumerate}
 
\section{Explanation:}

The protocol consists of three phases. The middle phase is an interactive phase running a sub protocol $\pi_{2,3}$ which takes input from three servers, which is their additive secret share mod 2, and outputs two additive share mod 3 shared by two servers. The first and last phase are non-interactive, meaning, they can be computed locally. 


\section{Example:}

\begin{itemize}
	\item Say at $j^{th}$ instance, $h_{1} = 1, h_{2} = 0, h_{3} = 1$ and server randomly chooses c = 2, so $c_{0} = 1, c_{1} = 0$
	\item $comb = 0, and d_{0} = 0, d_{1} = 0$ as computed by formula given above. 
	\item This satisfies the formula $c + d = h_{1} + h_{2} + h_{3} (mod 3)$, is true in this case.
	\item Server one and two apply $map_{G}$ function on their value $c and d \in \mathbb{Z}_3$
	
\end{itemize}
\end{document}
